<?_c
#
# search.bml
#
# A very basic search function that allows you to search a given journal in
# a few particular cases.
#
# Authors:
#      Mark Smith <mark@dreamwidth.org>
#
# Copyright (c) 2009-2013 by Dreamwidth Studios, LLC.
#
# This program is free software; you may redistribute it and/or modify it under
# the same terms as Perl itself. For a copy of the license, please reference
# 'perldoc perlartistic' or 'perldoc perlgpl'.
#
_c?><?page
body<=
<?_code
{
    use strict;
    use vars qw/ %POST %GET $title /;
    use Storable;

    # FIXME: make the UI a lot better :)

    $title = LJ::Lang::ml( '.title' );

    # if no gearman, bail
    my $gc = LJ::gearman_client();
    return LJ::Lang::ml( '.error.notconfigured' ) . "\n"
        unless $gc && @LJ::SPHINX_SEARCHD;

    # for pages that require authentication
    my $remote = LJ::get_remote();
    return "<?needlogin?>" unless $remote;

    # see what search mode...
    my $su = LJ::load_user( $POST{mode} || $GET{user} );
    my $q = LJ::strip_html( LJ::trim( $POST{query} || $GET{query} ) );
    my $sby = $POST{sort_by} || 'new';
    my $wc = $POST{with_comments} ? 1 : 0;
    $sby = 'new' unless $sby =~ /^(?:new|old|rel)$/;

    # helper sub for returning the search form
    my $search_form = sub {
        my $ret = "<form method='post' action='$LJ::SITEROOT/search'>" . LJ::form_auth();

        $ret .= LJ::html_check( { type => 'radio', selected => $su ? 0 : 1, id => 'm-global', name => 'mode',
                                  value => '', label => LJ::Lang::ml( '.label.sitesearch' ) } );

        my $tu = $su || $remote;
        if ( $tu->allow_search_by( $remote ) ) {
            $ret .= LJ::html_check( { type => 'radio', selected => $su ? 1 : 0, id => 'm-user', name => 'mode',
                                      value => $tu->user, label => LJ::Lang::ml( '.label.journalsearch' ) . " <strong>" . $tu->user . "</strong>", noescape => 1 } );
        }

        $ret .= '<br /><input type="text" name="query" maxlength="255" size="60" value="' . LJ::ehtml( $q ) . '">';
        $ret .= " <input type='submit' value='" . LJ::Lang::ml( '.button.search' ) . "' /><br />";
        $ret .= LJ::Lang::ml( '.sortby' );
        $ret .= LJ::html_select(
            { selected => $sby, name => 'sort_by' },
            new => LJ::Lang::ml( '.sort.date.new' ),
            old => LJ::Lang::ml( '.sort.date.old' ),
            rel => LJ::Lang::ml( '.sort.relevance' ),
        );
        $ret .= '<br />';
        if ( !$tu || $tu->is_paid ) {
            $ret .= LJ::html_check( { id => 'with_comments', name => 'with_comments',
                    selected => $wc, label => LJ::Lang::ml( '.comments.include' ) } );
            $ret .= '<br />' . LJ::Lang::ml( '.comments.include.note' );
        } else {
            $ret .= LJ::html_check( { id => 'with_comments', name => 'with_comments',
                    label => LJ::Lang::ml( '.comments.disabled' ),
                    disabled => 1 } );
            $ret .= '<br />' . LJ::Lang::ml( '.comments.disabled.note' );
        }
        $ret .= '</form>';

        return $ret;
    };

    # an error redisplays the form, with an error message
    my $error = sub {
        return $search_form->() . "<br /><?p <strong>" . LJ::Lang::ml( '.error' ) . "</strong> $_[0] p?>";
    };

    # if no $su, then this is a public search, that's allowed.  but if it's a user,
    # ensure that it's an account that we CAN search
    return $error->( LJ::Lang::ml( '.error.forbidden' ) )
        if $su && ! $su->allow_search_by( $remote );

    ################################################################################
    ################################################################################

    # give them the form to do a search if they haven't actually posted to us yet
    unless ( LJ::did_post() ) {
        # give them a form to enter their search options
        return "<?p " . LJ::Lang::ml( '.blurb', { sitename => $LJ::SITENAME } ) ." p?>" .
               $search_form->() .
               '</form><br /> <?p ' . LJ::Lang::ml( '.security.setting', { aopts => "href='$LJ::SITEROOT/manage/settings/?cat=privacy'" } ) . ' p?>';
    }

    ################################################################################
    ################################################################################

    # at this point, they have done a POST, which means they want to search something
    return $error->( LJ::Lang::ml( '.error.refresh' ) ) unless LJ::check_form_auth();

    # and make sure we got a query
    return $error->( LJ::Lang::ml( '.error.longquery' ) )
        if length( $q ) > 255;
    return $error->( LJ::Lang::ml( '.error.noquery' ) )
        unless $q;

    # if an offset, less than 1000 please
    my $offset = $GET{offset} + 0;
    return $error->( LJ::Lang::ml( '.error.wrongoffset' ) )
        if $offset < 0 || $offset > 1000;

    # we have to set a few flags on what to search.  default to public and no bits.
    my ( $ignore_security, $allowmask ) = ( 0, 0 );
    if ( $su ) {
        # if it's you, all posts, all bits
        if ( $remote->equals( $su ) ) {
            $ignore_security = 1;
        } elsif ( $su->is_community ) {
            # if it's a community you administer, also all bits
            if ( $remote->can_manage( $su ) ) {
                $ignore_security = 1;

            # for communities, member_of is the same as allow mask (no custom groups)
            } else {
                $allowmask = $remote->member_of( $su );
            }
        # otherwise, if they trust you, get the mask ...
        } elsif ( $su->trusts( $remote ) ) {
            $allowmask = $su->trustmask( $remote );
        }
    }

    # the arguments to the search (userid=0 implies global search)
    my $args = { userid => $su ? $su->id : 0, remoteid => $remote->id,
                 query => $q, offset => $offset, sort_by => $sby,
                 ignore_security => $ignore_security, allowmask => $allowmask,
                 include_comments => $wc };
    my $arg = Storable::nfreeze( $args );

    # so we know that they're searching something valid, send to gearman
    my $result;
    my $task = Gearman::Task->new(
        'sphinx_search', \$arg,
        {
            uniq => '-',
            on_complete => sub {
                my $res = $_[0] or return undef;
                $result = Storable::thaw( $$res );
            },
        }
    );

    # setup the task set for gearman... really, isn't there a way to make this
    # simpler?  oh well
    my $ts = $gc->new_task_set();
    $ts->add_task( $task );
    $ts->wait( timeout => 20 );

    # if we didn't get a result...
    return $error->( LJ::Lang::ml( '.error.timedout' ) )
        unless $result;

    # if we didn't get any matches...
    return $error->( LJ::Lang::ml( '.error.noresults', { query => $q, time => $result->{time} } ) )
        if $result->{total} <= 0;

    # now we can process the results and do something fascinating!
    my $matches = '<br /><br />';
    foreach my $match ( @{ $result->{matches} } ) {
        my $mu = LJ::load_userid( $match->{journalid} );
        my $pu = LJ::load_userid( $match->{poster_id} );

        # Do not show filtered icon for other users
        $match->{security} = 'access'
            if $match->{security} eq 'usemask' && ! $mu->equals( $remote );

        my $icon = {
                public  => '',
                private => LJ::img( "security-private",   "" ),
                usemask => LJ::img( "security-groups",    "" ),
                access  => LJ::img( "security-protected", "" ),
            }->{$match->{security}};

        my $tags = join( ', ', map { "<strong>" . $match->{tags}->{$_} . "</strong>" } keys %{ $match->{tags} } );
        $tags = "<br />" . LJ::Lang::ml( '.tags' ) . $tags
            if $tags;

        my $attribution;
        if ( $match->{jtalkid} > 0 ) {
            if ( $match->{poster_id} > 0 ) {
                $attribution = LJ::Lang::ml( '.attribution.comment', { journal => $mu->ljuser_display,
                        poster => $pu->ljuser_display } );
            } else {
                $attribution = LJ::Lang::ml( '.attribution.comment.anon', { journal => $mu->ljuser_display } );
            }
        } else {
            $attribution = $mu->is_comm
                            ? LJ::Lang::ml( '.attribution.comm', { journal => $mu->ljuser_display, poster => $pu->ljuser_display } )
                            : LJ::Lang::ml( '.attribution', { journal => $mu->ljuser_display } );
        }

        my $html = "<div class='searchres'>" . $attribution . ": " . $icon .
                    "<a href='" . $match->{url} . "'>" . $match->{subject} . "</a><br />" .
                    "<span class='exc'>" . $match->{excerpt} . "</span>" . $tags . "<br />" .
                    LJ::Lang::ml( '.date' ) . "<strong>" . $match->{eventtime} . "</strong><br /><br />" .
                    "</div>";
        $matches .= $html;
    }

    # build the rest of the search page
    my $ret = $search_form->() . $matches;

    # put some stats on the output
    my $matchct = scalar( @{ $result->{matches} } );
    my $skip = $offset > 0 ? " " . LJ::Lang::ml( '.results.skipped', { journal => $offset } ) : "";
    $ret .= "<span class='stats'>";
    $ret .= LJ::Lang::ml( '.results.displayed', { results => $matchct, total => $result->{total}, skipped => $skip, query => $q } );
    $ret .= " " . LJ::Lang::ml( '.results.time', { time => $result->{time} } );
    $ret .= "</span>";

    if ( $result->{total} > ( $offset + $matchct ) ) {
        my $offsetm = $offset + $matchct;
        $ret .= "<form method='post' action='$LJ::SITEROOT/search?offset=$offsetm'>" . LJ::form_auth() .
                "<input type='hidden' name='query' value='" . LJ::ehtml( $q ) . "'>" .
                "<input type='hidden' name='mode' value='" . ( $su ? $su->user : '' ) . "'>" .
                "<input type='hidden' name='sort_by' value='" . $sby . "'>" .
                "<input type='hidden' name='with_comments' value='" . $wc . "'>" .
                "<input type='submit' value='" . LJ::Lang::ml( '.button.more' ) . "' />" .
                "</form>";
    }

    return $ret;
}
_code?>
<=body
title=><?_code return $title; _code?>
head<=
<style type="text/css">
.exc { padding-left: 1em; font-style: italic; font-size: smaller; }
.stats { font-style: italic;  }
.searchres { margin: 0.2em 0em 0.2em 2em; }
</style>
<=head
page?>
