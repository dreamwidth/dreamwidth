<?_c
# This code was forked from the LiveJournal project owned and operated
# by Live Journal, Inc. The code has been modified and expanded by
# Dreamwidth Studios, LLC. These files were originally licensed under
# the terms of the license supplied by Live Journal, Inc, which can
# currently be found at:
#
# http://code.livejournal.org/trac/livejournal/browser/trunk/LICENSE-LiveJournal.txt
#
# In accordance with the original license, this code and all its
# modifications are provided under the GNU General Public License.
# A copy of that license can be found in the LICENSE file included as
# part of this distribution.
_c?>
<?_code
use strict;
{
    use DW::Controller::EditIcons;

    use vars qw(%GET %POST $title $body $head @errors);

    BML::set_language_scope("/editicons.bml");

    my $suffix = "";
    if (BML::get_request()->uri =~ /editicons-beta/) {
        $suffix = "-beta";
    }

    $title = $ML{'.title3'};
    $body = "";
    @errors = ();

    my $err = sub {
        $title = $ML{'Error'};
        $body = LJ::bad_input(@_);
        return;
    };

    unless (LJ::text_in(\%POST)) {
        return $err->("Invalid UTF-8 Input");
    }

    my $remote = LJ::get_remote();
    unless ($remote) {
        $body = "<?needlogin?>";
        return;
    }

    LJ::need_res(qw(
                    stc/editicons.css
                    js/6alib/progressbar.js
                    js/ljprogressbar.js
                    js/6alib/perlbal-uploadtrack.js
                    js/editicons.js
                    ));

    my $authas = $GET{'authas'} || $remote->{'user'};
    my $u = LJ::get_authas_user($authas) or
        return $err->($ML{'error.invalidauth'});

    # extra arguments for get requests
    my $getextra = $authas ne $remote->{'user'} ? "?authas=$authas" : '';

    # see if we're sorting by default order or by keyword
    my $keyword_sort =  $GET{'keywordSort'};
    if ( $keyword_sort ) {
        $getextra = $getextra ? $getextra . "&keywordSort=1" : "?keywordSort=1";
    }

    my $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
    my $picurl = LJ::CleanHTML::canonical_url($POST{'urlpic'});

    if ( $u->is_readonly ) {
        $title = "Read-only mode";
        $body = $LJ::MSG_READONLY_USER;
        return;
    }

    # update this user's activated pics
    $u->activate_userpics;

    # get userpics and count 'em
    my @userpics = LJ::Userpic->load_user_userpics($u);

    # get maximum number of userpics for this user
    my $max      = $u->count_max_userpics;

    my @info;

    my $factory_redirect;
    my $no_errors = 1;
    my $success_count = 0;

    my $display_rename = LJ::is_enabled( "icon_renames" ) ? 1 : 0 ;

    ### save/update mode
    if (LJ::did_post()) {

        ### save changes to existing pics
        if ($POST{'action:save'}) {
            my $refresh = DW::Controller::EditIcons::update_userpics(
                \%POST, \@errors, \@userpics, $u, $err );

            # push all the errors to info
            push(@info, @errors);

            # reload the pictures to account for deleted
            @userpics = LJ::Userpic->load_user_userpics($u) if $refresh;
        }

        ### no post data, so we'll parse the multipart data
        ### this means that we have a new pic to handle.
        unless (%POST) {
            my $r = DW::Request->get;
            my $size = $r->header_in("Content-Length");
            unless ($size) {
                return $err->("No content-length header: can't upload");
            }

            my $MAX_UPLOAD = LJ::Userpic->max_allowed_bytes($u);
            my $error;
            my $parsetomogile = $size > $MAX_UPLOAD + 2048;

            # array of map references
            my @uploaded_userpics;

            # three possibilites here:  small upload, in which case we
            # just parse it, large upload, in which case we save the
            # files to mogile, or coming from the factory.
            if (!$parsetomogile) {
                # BML::parse_multipart(\%POST, \$error, $MAX_UPLOAD + 2048);
                BML::parse_multipart(\%POST, \$error);

                # couldn't parse correctly
                if ($error) {
                    # return parse_multipart error
                    return $err->($error);
                }

                # parse the post parameters into an array of pics
                @uploaded_userpics = DW::Controller::EditIcons::parse_post_uploads(
                    \%POST, $u, $MAX_UPLOAD );
            }

            # if we're coming from the factory, we don't need to write
            # to mogilefs
            $parsetomogile = 0 if $POST{'src'} && $POST{'src'} eq 'factory';

            if ($parsetomogile) {
                my $res = parse_large_upload( \%POST, \$error, $u, $err );
                # large path

                # was there an error parsing the multipart form?
                if ($error) {
                    if ($error =~ /^\[(\S+?)\]/) {
                        my $code = $1;
                        if ($code eq "toolarge") {
                            return $err->(BML::ml('.error.filetoolarge',
                                                  { 'maxsize' => int($MAX_UPLOAD / 1024) }));
                        }
                        $error = BML::ml("BML.parse_multipart.$code");
                    }
                    return $err->($error) if $error;
                }

                # parse the post parameters into an array of pics
                @uploaded_userpics = DW::Controller::EditIcons::parse_post_uploads(
                    \%POST, $u, $MAX_UPLOAD );

            } elsif ($POST{'src'} eq "factory") {
                my $scaledsizemax = $POST{'scaledSizeMax'};
                my $x1 = $POST{'x1'}+0;
                my $x2 = $POST{'x2'}+0;
                my $y1 = $POST{'y1'}+0;
                my $y2 = $POST{'y2'}+0;
                my $index = $POST{'index'};

                return $err->("Invalid userpic creation parameters.") if (!$scaledsizemax || !$x2);

                my $picinfo = eval {
                    LJ::Userpic->get_upf_scaled(
                        x1     => $x1,
                        y1     => $y1,
                        x2     => $x2,
                        y2     => $y2,
                        border => $POST{'border'},
                        userid => $u->userid,
                        mogkey => "upf_$index:$u->{userid}",
                    );
                }
                or return $err->($ML{'.error.generatinguserpic'} . $@);

                my %current_upload = (
                    key   => 'userpic_0',
                    image => \${$picinfo->[0]},
                    index => 0,
                );
                $current_upload{$_} = $POST{$_}
                    foreach qw/ keywords default comments descriptions make_default /;
                push @uploaded_userpics, \%current_upload;
            }

            # throw an error if we didn't get a first pic.
            unless (@uploaded_userpics) {
                if ($POST{src} eq "file")  {
                    return $err->($ML{'.error.nofile'});
                } else {
                    return $err->($ML{'.error.nourl'});
                }
            }

            my $userpic_count = scalar @userpics;

            my $current_index = 0;
            # go through each userpic and try to create it
            foreach my $current_upload_ref (sort { $a->{"index"} cmp $b->{"index"} } @uploaded_userpics) {
                $current_index++;
                my $message_prefix = "";
                if (scalar @uploaded_userpics > 1) {
                    $message_prefix = BML::ml('.userpic', { "num" => $current_index });
                }
                my %current_upload = %$current_upload_ref;

                ## see if they have too many pictures uploaded
                my $inline;
                if ($userpic_count >= $max) {
                    push @info, BML::ml('.error.toomanypics4', { "num" => $max });
                    $no_errors = 0;
                } elsif ($current_upload{"error"}) {
                    push @info, $message_prefix . "$current_upload{error}";
                    $no_errors = 0;
                } elsif ($current_upload{requires_factory}) {
                    DW::BlobStore->store(
                        temp => "upf_$current_upload{index}:$u->{userid}",
                        $current_upload{image},
                    );

                    $factory_redirect = "$LJ::SITEROOT/tools/userpicfactory?keywords=" .
                        BML::eurl($current_upload{keywords}) . "&comments=" .
                        BML::eurl($current_upload{comments}) . "&descriptions=" .
                        BML::eurl($current_upload{descriptions}) .
                        "&imageWidth=" . BML::eurl($current_upload{imagew}) .
                        "&imageHeight=" . BML::eurl($current_upload{imageh}) .
                        "&make_default=" . BML::eurl($current_upload{make_default}) .
                        "&index=" . BML::eurl($current_upload{index}) . '&authas=' .
                        BML::eurl($GET{'authas'}) . '&sfx=' . BML::eurl($suffix);

                    # go ahead and add the error message to the info string;
                    # this will only get displayed if we don't do the redirect.
                    push @info, $message_prefix . $ML{'.error.toolarge.separately'};
                } else {
                    my $userpic = eval { LJ::Userpic->create($u, data => $current_upload{image}); };
                    if (!$userpic) {
                        $@ = $@->as_html if $@->isa('LJ::Error');
                        push @info, $message_prefix . "$@";
                        $no_errors = 0;
                    } else {
                        my $picid = $userpic->id;

                        push @info, $message_prefix . $ML{'.uploadsuccessful'};
                        $success_count++;

                        $userpic->make_default
                            if $current_upload{make_default};
                        $userpic->set_keywords( $current_upload{keywords} )
                            if defined $current_upload{keywords};
                        $userpic->set_comment( $current_upload{comments} )
                            if $current_upload{comments};
                        $userpic->set_description( $current_upload{descriptions} )
                            if $current_upload{descriptions};
                        $userpic->set_fullurl( $current_upload{url} )
                            if $POST{url};

                        $userpic_count++;
                    }
                }

            }
            # yay we created new pics, reload the @userpics
            @userpics = LJ::Userpic->load_user_userpics($u);
        }

        if ($factory_redirect && $no_errors) {
            if ($success_count) {
                $factory_redirect .= '&successcount=' . $success_count;
            }
            return BML::redirect($factory_redirect);
        }

        # now fall through to edit page and show the updated userpic info
        # redirect back to ourselves
        $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
        if ($returl) {
            my $redir_host;
            $redir_host = $1 if $returl =~ m!^https?://([\.:\w-]+)!i;
            return BML::redirect($returl) if $LJ::REDIRECT_ALLOWED{$redir_host};
        }
    }

    # authas switcher form
    $body .= "<form method='get' id='userpic_authas' action='editicons$suffix'>\n";
    $body .= LJ::make_authas_select($remote, { 'authas' => $GET{'authas'} }) . "\n";
    $body .= "</form>\n\n";

    # if we're disabling media, say so
    $body .= "<?warningbar $ML{'error.mediauploadsdisabled'} warningbar?>"
        if $LJ::DISABLE_MEDIA_UPLOADS;

    if (@info) {
        $body .= '<div class="warningbar">';
        $body .= "<div>$_</div>" foreach @info;
        $body .= '</div>';
    }

    # print out upload pic box
    my $emit_upload_box = sub {
        if (scalar @userpics < $max) {

            # upload form (with perlbal upload-tracking)
            $body .= qq {
                <iframe name='upiframe' width='1' height='1' style='border: none'></iframe>
                <div id='uploadBox' class='highlight-box box pkg'><div id='uploadBox-inner'>
                    <form enctype="multipart/form-data" action="editicons$suffix$getextra" method='post' id='uploadPic'>
                    <input type="hidden" id="go_to" name="go_to" value="editicons$suffix$getextra" />
            };

            $body .= "<?h1 $ML{'.uploadheader'} h1?>\n";
            $body .= "<p class='detail'><a href='javascript:void(0)' onclick='toggleElement(\"upload_desc\")' id='upload_desc_link'>$ML{'.about.icons'}</a></p>";
            $body .= "<div id='upload_desc'>";
            $body .= "<?p $ML{'.uploaddesc'} p?>\n";
            $body .= "</div><!-- end #uploaddesc -->";

            $body .= "<div id='upload_wrapper' class='pkg'>\n";
            $body .= "<p class='pkg'>\n";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'id' => 'radio_file',
                                      'class' => 'radio', 'value' => 'file', 'selected' => '1',
                                      'accesskey' => $ML{'.fromfile.key'} }) . "\n";
            $body .= "<label for='radio_file'>$ML{'.fromfile'}</label><br />\n";
            $body .= "<input type='file' class='file' name='userpic_0' id='userpic_0' size='18' style='margin: 0em 0em 0.5em 2em;' />\n";
            $body .= "</p>\n";
            $body .= "<p class='pkg'>\n";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'value' => 'url',
                                      'id' => 'radio_url', 'class' => 'radio', 'accesskey' => $ML{'.fromurl.key'} }) . "\n";
            $body .= "<label for='radio_url'>$ML{'.fromurl'}</label><br />\n";
            $body .= LJ::html_text({ 'name' => 'urlpic_0', 'id' => 'urlpic_0', class => 'text', style => 'margin: 0em 0em 0.5em 2em;' }) . "\n";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.formats.desc'}</p>\n";
            $body .= "</div>\n";

            $body .= "<hr class='hr' />";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='keywords_0'>$ML{'.label.keywords'}</label>\n";
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text({ 'name' => 'keywords_0', class => 'text', id => 'keywords_0' }) . "\n";
            $body .= LJ::help_icon_html('upic_keywords') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.keywords.desc'}</p>\n";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='comments_0'>$ML{'.label.comment'}</label>\n";
            my $comments = $POST{'comments'};
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text({ 'name' => 'comments_0', 'class' => 'text', id => 'comments_0', 'maxlength' => LJ::CMAX_UPIC_COMMENT, 'value', $comments }) . "\n";
            $body .= LJ::help_icon_html('upic_comments') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.comment.desc'}</p>\n";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='descriptions_0'>$ML{'.label.description'}</label>\n";
            my $descriptions = $POST{'descriptions'};
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text( { name => 'descriptions_0', class => 'text', id => 'descriptions_0', 'maxlength' => LJ::CMAX_UPIC_DESCRIPTION, value => $descriptions } ) . "\n";
            $body .= LJ::help_icon_html('upic_descriptions') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            # link to the alt text faq; long and useful
            my $faq = LJ::Hooks::run_hook( 'faqlink', 'alttext', $ML{'.label.description.faq'} );
            $body .= "<p
            class='detail'>$ML{'.label.description.desc'} $faq</p>";

            $body .= "<p class='pkg'>\n";
            $body .= "<span id='main_make_default'>";
            $body .= LJ::html_check({ 'type' => 'checkbox',
                                      'name' => 'make_default',
                                      'id' => 'make_default_0',
                                      'value' => '0',
                                      'selected' => @userpics ? 0 : 1,
                                      'accesskey' => $ML{'.makedefault.key'} });
            $body .= "</span>";

            $body .= "<label for='make_default_0'>$ML{'.makedefault'}</label>\n";
            $body .= "</p>\n";

            # adding multi-upload option if mogile is enabled

            my $remaining_uploads = $max - scalar @userpics;
            if ($remaining_uploads >= 2) {
                $body .= "<div id='multi_insert'></div>";
                $body .= "<div id='no_default_insert'></div>";
                $body .= "<p class='pkg' id='multi_insert_buttons'>\n";

                $body .= "<input type='button' value='$ML{'.btn.addfile'}' onclick='javascript:addNewUpload(\"file\");' /> <input type='button' value='$ML{'.btn.addurl'}' onclick='javascript:addNewUpload(\"url\");'/>\n";
                $body .= "<script type='text/javascript'>\n";
                $body .= "maxcounter = $remaining_uploads;\n";
                $body .= "allowComments = true;\n";
                $body .= "allowDescriptions = true;\n";

                $body .= "ep_labels.comment = '$ML{'.label.comment'}';\n";
                $body .= "ep_labels.description = '$ML{'.label.description'}';\n";
                $body .= "ep_labels.fromfile = '$ML{'.fromfile'}';\n";
                $body .= "ep_labels.fromurl = '$ML{'.fromurl'}';\n";
                $body .= "ep_labels.keepdefault = '$ML{'.label.keepdefault'}';\n";
                $body .= "ep_labels.keywords = '$ML{'.label.keywords'}';\n";
                $body .= "ep_labels.makedefault = '$ML{'.makedefault'}';\n";
                $body .= "ep_labels.makedefaultkey = '$ML{'.makedefault.key'}';\n";
                $body .= "ep_labels.remove = '$ML{'.btn.remove'}';\n";

                $body .="</script>\n";
                $body .= "</p>\n";
            }

            $body .= "<p class='pkg' id='submit_wrapper'>";
            $body .= LJ::html_submit(undef, $ML{'.btn.proceed'},
                                     { disabled => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "</p>\n";
            $body .= q {
                    </form>
                    </div></div><!-- end #uploadBox -->
                    <div id="uploadStatus" style="display: none;"></div>
                    <div id="progressBar" style="display: none;"></div>
                };

        } else {
            $body .= "<div id='limit'>\n";
            $body .= BML::ml('.error.toomanypics_standout', { num => $max });
            $body .= "</div><!-- end #limit -->";
        }
        $body .= " \n\n";
    };

    $emit_upload_box->();

    # print out each pic and editing fields
    if ( scalar @userpics ) {
        $body .= "<div id='current_userpics'>";
        $body .= "<form method='post' action='editicons$suffix$getextra'>";
        $body .= LJ::form_auth();

        $body .= qq {
                <?h1 $ML{'.curpics'} h1?>
                <?p $ML{'.curpics.desc2'} p?>
                <div class='EditIconsStatus'>
            };

        # Check for default userpic keywords
        my $nokeywords = 0;
        foreach my $pic ( @userpics ) {
            my $keywords = $pic->keywords;
            if ( substr( $keywords, 0, 4 ) eq "pic#" ) {
                $nokeywords = 1;
            }
        }

        if ( $nokeywords ) {
            $body .= "<div class='highlight-box' id='no_keywords'>";
            $body .= BML::ml('.error.nokeywords');
            $body .= "</div>";
        }

        $body .= "<p><strong>" . BML::ml( '.piclimitstatus', { current => scalar @userpics, max => $max } ) . "</strong> ";
        $body .= BML::ml( '.view.allicons', { aopts => "href='" . $u->allpics_base . "'" } ) . "</p>";
        if (scalar @userpics >= $max) {
            $body .= "<p>".BML::ml('cprod.editpics.text7.v1',{ "num" => $max })."</p>";
        }

        # show sort options
        $body .= "<p>";
        $body .= $keyword_sort ? '<a href = "/editicons">' . "$ML{'.sort.default'}</a>" : "$ML{'.sort.default'}";
        $body .=" | ";
        $body .= $keyword_sort ? "$ML{'.sort.keyword'}" : '<a href = "/editicons?keywordSort=1">' . "$ML{'.sort.keyword'}</a>";
        $body .= "</p>\n";

        $body .= "</div>";

        $body .= "<div id='list_userpics' style='width: 98%; float: left;'>";

        if ( $keyword_sort ) {
            @userpics = LJ::Userpic->sort( \@userpics );
        }

        foreach my $pic ( @userpics ) {
            my $pid = $pic->id;

            $body .= "<div class='pkg userpic_wrapper'>";
            $body .= "<span class='EditIconsUserpic'>" .  $pic->imgtag . "</span>\n";

            # FIXME: if no keywords then light grey text and empty out when you click in it
            my $keywords = $pic->keywords;
            my $comment = $pic->comment;
            my $description = $pic->description;
            $body .= "<div class='userpic_controls'  style='float: left; width: auto;'>";
            $body .= "<div class='userpic_keywords pkg'>\n";
            $body .= "<label class='left' for='kw_$pid'>$ML{'.label.keywords'}</label>\n ";
            $body .= LJ::html_text({'name' => "kw_$pid", 'class' => "text", 'id' => "kw_$pid",
                                    'value' => $keywords,
                                    'disabled' => $pic->inactive,
                                    'onfocus' => $display_rename ? "\$(\'rename_div_$pid\').style.display = \'block\';" : ""
                                   }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "kw_orig_$pid",
                                       'value' => $keywords }) . "\n";
            if ($display_rename) {
                $body .= "<div id='rename_div_$pid' class='userpic_rename pkg'>\n";
                $body .= "<script type='text/javascript'>document.getElementById('rename_div_$pid').style.display = 'none';</script>\n";
                if ( $u->userpic_have_mapid ) {
                    $body .= LJ::html_check({ 'type' => 'checkbox', 'name' => "rename_keyword_$pid", 'class' => "checkbox",
                                              'id' => "rename_keyword_$pid", 'value' => 1,
                                              'disabled' => $LJ::DISABLE_MEDIA_UPLOADS });
                    $body .= "<label for='rename_keyword_$pid'>$ML{'.label.rename'}</label>";
                } else {
                    $body .= "$ML{'.label.rename.disabled'}";
                }

                $body .= "</div>\n";
            }
            $body .= "</div>\n";

            $body .= "<div class='userpic_comments pkg'>\n";
            $body .= "<label class='left' for='com_$pid'>$ML{'.label.comment'}</label>\n ";
            $body .= LJ::html_text({ 'name' => "com_$pid", 'class' => "text", 'id' => "com_$pid",
                                     'value' => $comment,
                                     'maxlength' => LJ::CMAX_UPIC_COMMENT,
                                     'disabled' => $pic->inactive }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "com_orig_$pid",
                                       'value' => $comment }) . "\n";

            $body .= "</div>\n";

            $body .= "<div class='userpic_descriptions pkg'>\n";
            $body .= "<label class='left' for='desc_$pid'>$ML{'.label.description'}</label>\n ";
            $body .= LJ::html_text({ 'name' => "desc_$pid", 'class' => "text", 'id' => "desc_$pid",
                                     'value' => $description,
                                     'maxlength' => LJ::CMAX_UPIC_DESCRIPTION,
                                     'disabled' => $pic->inactive }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "desc_orig_$pid",
                                       'value' => $description }) . "\n";

            $body .= "</div>\n";

            $body .= "<div class='userpic_defaultdelete pkg'>";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'defaultpic', 'class' => "radio", 'value' => $pid,
                                      'selected' => $pic->is_default ? 1 : 0,
                                      'id' => "def_$pid",
                                      'disabled' => $pic->inactive });
            $body .= "<label class='userpic_default_label' for='def_$pid'>$ML{'.label.default'}</label> ";
            $body .= LJ::html_check({ 'type' => 'checkbox', 'name' => "delete_$pid", 'class' => "checkbox",
                                      'id' => "del_$pid", 'value' => 1,
                                      'disabled' => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "<label for='del_$pid'>$ML{'.label.delete'}</label>";
            if ($pic->inactive) {
                $body .= " &nbsp;<i>[$ML{'userpic.inactive'}]</i> " . LJ::help_icon('userpic_inactive');
                # we need to indicate explicitly that this is disabled due to
                # being inactive, in case it becomes active again between page
                # render and page submit
                $body .= LJ::html_hidden({ 'name' => "pic_inactive_$pid",
                                           'value' => "1" }) . "\n";
            }
            $body .= "</div>";
            $body .= "</div>";
            $body .= "</div>";
            $body .= "<hr class='hr' />";
        }

        $body .= "</div><!-- end #list_userpics -->";
        # no default userpic
        $body .= "<p id='no_default_userpic' style='clear: both;'>";
        $body .= LJ::html_check({ 'name' => 'defaultpic',
                                  'value' => 0,
                                  'type' => 'radio',
                                  'class' => 'radio',
                                  'selected' => $u->{'defaultpicid'} == 0,
                                  'raw' => "id='nodefpic'" });
        $body .= "<label for='nodefpic'>$ML{'.nodefault'}</label></p>";
        $body .= "<div class='action-box'><ul class='inner nostyle'><li>" . LJ::html_submit('action:save', $ML{'.btn.save'}) . "</li></ul></div><div class='clear-floats'></div>";
        $body .= "</form>";
        $body .= "</div><!-- end #current_userpics -->";
        $body .= "<script type='text/javascript'>\n";
        $body .= "editiconsInit();\n";
        $body .= "</script>\n";

    } else {
        $body .= qq {
                <?h1 $ML{'.nopics'} h1?>
                <?p $ML{'.noneupload2'} p?>
            };
    }

    sub parse_large_upload {
        my ( $POST, $errorref, $user, $err ) = @_;

        my %upload = (); # { spool_data, spool_file_name, filename, bytes, md5sum, md5ctx, mime }
        my @uploaded_files = ();
        my $curr_name;

        # called when the beginning of an upload is encountered
        my $hook_newheaders = sub {
            my ( $name, $filename ) = @_;
            $curr_name = $name;
            $POST->{$curr_name} = '';
            return 1 unless $curr_name =~ /userpic.*/;

            # new file, need to create a filehandle, etc
            %upload = ();
            $upload{filename} = $filename;
            $upload{md5ctx} = new Digest::MD5;

            my @tokens = split(/_/, $curr_name);
            my $counter = $tokens[1];

            $upload{spool_file_name} = "upf_${counter}:$user->{userid}";
            $upload{spool_data} = '';

            push @uploaded_files, $upload{spool_file_name};
            return 1;
        };

        # called as data is received
        my $hook_data = sub {
            my ( $len, $data ) = @_;
            unless ( $curr_name =~ /userpic.*/ ) {
                $POST->{$curr_name} .= $data;
                return 1;
            }

            # check that we've not exceeded the max read limit
            my $max_read = (1<<20) * 5; # 5 MiB
            $upload{bytes} += $len;
            if ( $upload{bytes} > $max_read ) {
                $$errorref = "Upload max $max_read exceeded at $upload{bytes} bytes";
                return $err->( $$errorref );
            }

            $upload{md5ctx}->add($data);
            $upload{spool_data} .= $data;

            return 1;
        };

        # called when the end of an upload is encountered
        my $hook_enddata = sub {
            return 1 unless $curr_name =~ /userpic.*/;

            # since we've just finished a potentially slow upload, we need to
            # make sure the database handles in DBI::Role's cache haven't expired,
            # so we'll just trigger a revalidation now so that subsequent database
            # calls will be safe.
            $LJ::DBIRole->clear_req_cache();

            # don't try to operate on 0-length spoolfiles
            unless ( $upload{bytes} ) {
                %upload = ();
                return 1;
            }
            unless ( length $upload{spool_data} > 0 ) {
                $$errorref = "Failed to read a file";
                return $err->( $$errorref );
            }

            # Get MIME type from magic bytes
            $upload{mime} = File::Type->new->mime_type( $upload{spool_data} );
            unless ( $upload{mime} ) {
                $$errorref = "Unknown format for upload";
                return $err->( $$errorref );
            }

            # finished adding data for md5, create digest (but don't destroy original)
            $upload{md5sum} = $upload{md5ctx}->digest;
            $POST->{$curr_name} = \$upload{spool_data};
            return 1;
        };


        # parse multipart-mime submission, one chunk at a time,
        # calling our hooks as we go to put uploads in temporary
        # MogileFS filehandles
        my $retval = eval { BML::parse_multipart_interactive($errorref, {
            newheaders => $hook_newheaders,
            data       => $hook_data,
            enddata    => $hook_enddata,
                                                             }); };

        # if BML::Parse_multipart_interactive failed, we need to add
        # all of our gpics to the gpic_delete queue.  if any of them
        # still have refcounts, they won't really be deleted because
        # the async job will realize and leave them alone
        unless ( $retval ) {
            # if we hit a parse error, delete the uploaded files
            foreach my $mogkey ( @uploaded_files ) {
                DW::BlobStore->delete( temp => $mogkey );
            }

            if (index(lc($$errorref), 'unknown format') == 0) {
                $$errorref = BML::ml(".error.unknowntype");
            } else {
                $$errorref = "couldn't parse upload: $$errorref";
            }
            # the error page is printed in the caller
            return 0;
        }

        return $retval;
    }

    return;
}


_code?><?page
    head=><?_code return $head; _code?>
    title=><?_code return $title; _code?>
    body=><?_code return $body; _code?>
    page?>
