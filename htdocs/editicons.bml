<?_c
# This code was forked from the LiveJournal project owned and operated
# by Live Journal, Inc. The code has been modified and expanded by
# Dreamwidth Studios, LLC. These files were originally licensed under
# the terms of the license supplied by Live Journal, Inc, which can
# currently be found at:
#
# http://code.livejournal.org/trac/livejournal/browser/trunk/LICENSE-LiveJournal.txt
#
# In accordance with the original license, this code and all its
# modifications are provided under the GNU General Public License.
# A copy of that license can be found in the LICENSE file included as
# part of this distribution.
_c?>
<?_code
use strict;
{
    use vars qw(%GET %POST $title $body $head @errors);
    use Carp qw(croak);

    LJ::set_active_crumb('manageuserpics');
    BML::set_language_scope("/editicons.bml");

    my $suffix = "";
    if (BML::get_request()->uri =~ /editicons-beta/) {
        $suffix = "-beta";
    }

    $title = $ML{'.title3'};
    $body = "";
    @errors = ();

    my $err = sub {
        $title = $ML{'Error'};
        $body = LJ::bad_input(@_);
        return;
    };

    unless (LJ::text_in(\%POST)) {
        return $err->("Invalid UTF-8 Input");
    }

    my $remote = LJ::get_remote();
    unless ($remote) {
        $body = "<?needlogin?>";
        return;
    }

    LJ::need_res(qw(
                    stc/editicons.css
                    js/6alib/progressbar.js
                    js/ljprogressbar.js
                    js/6alib/perlbal-uploadtrack.js
                    js/editicons.js
                    ));

    my $authas = $GET{'authas'} || $remote->{'user'};
    my $u = LJ::get_authas_user($authas) or
        return $err->($ML{'error.invalidauth'});

    # extra arguments for get requests
    my $getextra = $authas ne $remote->{'user'} ? "?authas=$authas" : '';

    # see if we're sorting by default order or by keyword
    my $keyword_sort =  $GET{'keywordSort'};
    if ( $keyword_sort ) {
        $getextra = $getextra ? $getextra . "&keywordSort=1" : "?keywordSort=1";
    }

    my $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
    my $picurl = LJ::CleanHTML::canonical_url($POST{'urlpic'});

    if ( $u->is_readonly ) {
        $title = "Read-only mode";
        $body = $LJ::MSG_READONLY_USER;
        return;
    }

    # update this user's activated pics
    $u->activate_userpics;

    # get userpics and count 'em
    my @userpics = LJ::Userpic->load_user_userpics($u);

    # get maximum number of userpics for this user
    my $max      = $u->count_max_userpics;

    my @info;

    my $factory_redirect;
    my $no_errors = 1;
    my $success_count = 0;

    my $display_rename = LJ::is_enabled( "icon_renames" ) ? 1 : 0 ;

    ### save/update mode
    if (LJ::did_post()) {

        ### save changes to existing pics
        if ($POST{'action:save'}) {
            my $refresh = update_userpics(\@userpics, $u, $err);

            # push all the errors to info
            push(@info, @errors);

            # reload the pictures to account for deleted
            @userpics = LJ::Userpic->load_user_userpics($u) if $refresh;
        }

        ### no post data, so we'll parse the multipart data
        ### this means that we have a new pic to handle.
        unless (%POST) {
            my $r = DW::Request->get;
            my $size = $r->header_in("Content-Length");
            unless ($size) {
                return $err->("No content-length header: can't upload");
            }

            my $MAX_UPLOAD = LJ::Userpic->max_allowed_bytes($u);
            my $error;

            # act like the factory is disabled if no mogile
            my $factory_disabled = !LJ::is_enabled('userpicfactory') || !LJ::mogclient();
            my $mogcli = LJ::mogclient();

            # just return an error immediately if there's no mogile and the upload
            # size is too big.
            if (!$mogcli && ($size > $MAX_UPLOAD + 2048)) {
                # we have to suck in the data otherwise the browser gets upset because we're
                # closing the connection before reading in all the data and it will sometimes
                # refuse to show the error.

                # pretend to tell apache that we care about parsing the data, but we really don't
                my $bogus = sub {return 1;};
                BML::parse_multipart_interactive(\$error, {
                    newheaders => $bogus,
                    data       => $bogus,
                    enddata    => $bogus,
                                                 });

                return $err->(BML::ml('.error.filetoolarge',
                                      { 'maxsize' => int($MAX_UPLOAD / 1024) }));
                                           
            }

            my $parsetomogile = !$factory_disabled && ($size > $MAX_UPLOAD + 2048);

            # array of map references
            my @uploaded_userpics; 

            # three possibilites here:  small upload, in which case we 
            # just parse it, large upload, in which case we save the
            # files to mogile, or coming from the factory.
            if (!$parsetomogile) {
                # BML::parse_multipart(\%POST, \$error, $MAX_UPLOAD + 2048);
                BML::parse_multipart(\%POST, \$error);

                # couldn't parse correctly
                if ($error) {
                    # return parse_multipart error
                    return $err->($error);
                }

                # parse the post parameters into an array of pics
                @uploaded_userpics = parse_post_uploads(\%POST, $u, $MAX_UPLOAD, $factory_disabled);

            } 

            # if we're coming from the factory, we don't need to write
            # to mogilefs
            $parsetomogile = 0 if ($POST{'src'} && $POST{'src'} eq 'factory');

            if ($parsetomogile) {
                my $res = parse_large_upload(\%POST, \$error, $u, $err);
                # large path

                # was there an error parsing the multipart form?
                if ($error) {
                    if ($error =~ /^\[(\S+?)\]/) {
                        my $code = $1;
                        if ($code eq "toolarge") {
                            return $err->(BML::ml('.error.filetoolarge',
                                                  { 'maxsize' => int($MAX_UPLOAD / 1024) }));
                        }
                        $error = BML::ml("BML.parse_multipart.$code");
                    }
                    return $err->($error) if $error;
                }

                # parse the post parameters into an array of pics
                @uploaded_userpics = parse_post_uploads(\%POST, $u, $MAX_UPLOAD, $factory_disabled);

            } elsif ($POST{'src'} eq "factory") {

                my $scaledsizemax = $POST{'scaledSizeMax'};
                my $x1 = $POST{'x1'}+0;
                my $x2 = $POST{'x2'}+0;
                my $y1 = $POST{'y1'}+0;
                my $y2 = $POST{'y2'}+0;
                my $index = $POST{'index'};

                return $err->("Invalid userpic creation parameters.") if (!$scaledsizemax || !$x2);

                my $picinfo = eval {
                    LJ::Userpic->get_upf_scaled(
                        x1 => $x1,
                        y1 => $y1,
                        x2 => $x2,
                        y2 => $y2,
                        border => $POST{'border'},
                        userid  => $u->userid,
                        mogkey => "upf_$index:$u->{userid}",
                        );
                }
                or return $err->($ML{'.error.generatinguserpic'} . $@);

                my %current_upload;
                $current_upload{key} = "userpic_0";
                $current_upload{image} = \${ $picinfo->[0] };
                $current_upload{keywords} = $POST{keywords};
                $current_upload{default} = $POST{default};
                $current_upload{comments} = $POST{comments};
                $current_upload{descriptions} = $POST{descriptions};
                $current_upload{make_default} = $POST{make_default};
                $current_upload{index} = 0;

                push @uploaded_userpics, \%current_upload;

            } 
            
            # throw an error if we didn't get a first pic.

            unless (@uploaded_userpics) {
                if ($POST{src} eq "file")  {
                    return $err->($ML{'.error.nofile'});
                } else {
                    return $err->($ML{'.error.nourl'});
                }
            }
            
            my $userpic_count = scalar @userpics;

            my $current_index = 0;
            # go through each userpic and try to create it
            foreach my $current_upload_ref (sort { $a->{"index"} cmp $b->{"index"} } @uploaded_userpics) {
                $current_index++;
                my $message_prefix = "";
                if (scalar @uploaded_userpics > 1) {
                    $message_prefix = BML::ml('.userpic', { "num" => $current_index });
                }
                my %current_upload = %$current_upload_ref;
                
                ## see if they have too many pictures uploaded
                my $inline;
                if ($userpic_count >= $max) {
                    if ($inline .= LJ::Hooks::run_hook("cprod_inline", $u, 'EditPicsMax')) {
                        push @info, $inline;
                        $no_errors = 0;
                    } else {
                        push @info, BML::ml('.error.toomanypics4', { "num" => $max });
                        $no_errors = 0;
                    }
                } elsif ($current_upload{"error"}) {
                    push @info, $message_prefix . "$current_upload{error}";
                    $no_errors = 0;
                } elsif ($current_upload{requires_factory}) {
                    unless ($current_upload{spool_fh}) {
                        LJ::mogclient()->store_content("upf_$current_upload{index}:$u->{userid}", "temp", $current_upload{image});
                    }

                    $factory_redirect = "$LJ::SITEROOT/tools/userpicfactory?keywords=" .
                        BML::eurl($current_upload{keywords}) . "&comments=" .
                        BML::eurl($current_upload{comments}) . "&descriptions=" .
                        BML::eurl($current_upload{descriptions}) .
                        "&imageWidth=" . BML::eurl($current_upload{imagew}) . 
                        "&imageHeight=" . BML::eurl($current_upload{imageh}) .
                        "&make_default=" . BML::eurl($current_upload{make_default}) . 
                        "&index=" . BML::eurl($current_upload{index}) . '&authas=' .
                        BML::eurl($GET{'authas'}) . '&sfx=' . BML::eurl($suffix);
                    
                    # go ahead and add the error message to the info string;
                    # this will only get displayed if we don't do the redirect.
                    push @info, $message_prefix . $ML{'.error.toolarge.separately'};
                } else {
                    my $userpic = eval { LJ::Userpic->create($u, data => $current_upload{image}); };
                    if (!$userpic) {
                        $@ = $@->as_html if $@->isa('LJ::Error');
                        push @info, $message_prefix . "$@";
                        $no_errors = 0;
                    } else {
                        my $picid = $userpic->id;
                        
                        push @info, $message_prefix . $ML{'.uploadsuccessful'};
                        $success_count++;

                        # make it their default pic?
                        if ($current_upload{make_default}) {
                            $userpic->make_default;
                        }
                        $userpic->set_keywords($current_upload{keywords}) if $current_upload{keywords};
                        $userpic->set_comment($current_upload{comments})  if $current_upload{comments};
                        $userpic->set_description($current_upload{descriptions}) if $current_upload{descriptions};
                        $userpic->set_fullurl($current_upload{url})       if $POST{url};
                        
                        $userpic_count++;
                    }
                }
                
            }
            # yay we created new pics, reload the @userpics
            @userpics = LJ::Userpic->load_user_userpics($u);
        }
        
        if ($factory_redirect && $no_errors) {
            if ($success_count) {
                $factory_redirect .= '&successcount=' . $success_count;
            }
            return BML::redirect($factory_redirect);
        }

        # now fall through to edit page and show the updated userpic info
        # redirect back to ourselves
        $returl = LJ::CleanHTML::canonical_url($POST{'ret'});
        if ($returl) {
            my $redir_host;
            $redir_host = $1 if $returl =~ m!^http://([\.:\w-]+)!i;
            return BML::redirect($returl) if $LJ::REDIRECT_ALLOWED{$redir_host};
        }
    }

    # authas switcher form
    $body .= "<form method='get' id='userpic_authas' action='editicons$suffix'>\n";
    $body .= LJ::make_authas_select($remote, { 'authas' => $GET{'authas'} }) . "\n";
    $body .= "</form>\n\n";

    # if we're disabling media, say so
    $body .= "<?warningbar $ML{'error.mediauploadsdisabled'} warningbar?>"
        if $LJ::DISABLE_MEDIA_UPLOADS;

    if (@info) {
        $body .= '<div class="warningbar">';
        $body .= "<div>$_</div>" foreach @info;
        $body .= '</div>';
    }

    # print out upload pic box
    my $emit_upload_box = sub {
        if (scalar @userpics < $max) {

            # upload form (with perlbal upload-tracking)
            $body .= qq {
                <iframe name='upiframe' width='1' height='1' style='border: none'></iframe>
                <div id='uploadBox' class='highlight-box box pkg'><div id='uploadBox-inner'>
                    <form enctype="multipart/form-data" action="editicons$suffix$getextra" method='post' id='uploadPic'>
                    <input type="hidden" id="go_to" name="go_to" value="editicons$suffix$getextra" />
            };

            $body .= "<?h1 $ML{'.uploadheader'} h1?>\n";
            $body .= "<p class='detail'><a href='javascript:void(0)' onclick='toggleElement(\"upload_desc\")' id='upload_desc_link'>$ML{'.about.icons'}</a></p>";
            $body .= "<div id='upload_desc'>";
            $body .= "<?p $ML{'.uploaddesc'} p?>\n";
            $body .= "</div><!-- end #uploaddesc -->";

            $body .= "<div id='upload_wrapper' class='pkg'>\n";
            $body .= "<p class='pkg'>\n";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'id' => 'radio_file',
                                      'class' => 'radio', 'value' => 'file', 'selected' => '1', 
                                      'accesskey' => $ML{'.fromfile.key'} }) . "\n";
            $body .= "<label for='radio_file'>$ML{'.fromfile'}</label><br />\n";
            $body .= "<input type='file' class='file' name='userpic_0' id='userpic_0' size='18' style='margin: 0em 0em 0.5em 2em;' />\n";
            $body .= "</p>\n";
            $body .= "<p class='pkg'>\n";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'src', 'value' => 'url',
                                      'id' => 'radio_url', 'class' => 'radio', 'accesskey' => $ML{'.fromurl.key'} }) . "\n";
            $body .= "<label for='radio_url'>$ML{'.fromurl'}</label><br />\n";
            $body .= LJ::html_text({ 'name' => 'urlpic_0', 'id' => 'urlpic_0', class => 'text', style => 'margin: 0em 0em 0.5em 2em;' }) . "\n";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.formats.desc'}</p>\n";
            $body .= "</div>\n";

            $body .= "<hr class='hr' />";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='keywords_0'>$ML{'.label.keywords'}</label>\n";
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text({ 'name' => 'keywords_0', class => 'text', id => 'keywords_0' }) . "\n";
            $body .= LJ::help_icon_html('upic_keywords') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.keywords.desc'}</p>\n";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='comments_0'>$ML{'.label.comment'}</label>\n";
            my $comments = $POST{'comments'};
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text({ 'name' => 'comments_0', 'class' => 'text', id => 'comments_0', 'maxlength' => LJ::CMAX_UPIC_COMMENT, 'value', $comments }) . "\n";
            $body .= LJ::help_icon_html('upic_comments') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.comment.desc'}</p>\n";

            $body .= "<p class='pkg'>\n";
            $body .= "<label class='left' for='descriptions_0'>$ML{'.label.description'}</label>\n";
            my $descriptions = $POST{'descriptions'};
            $body .= "<span class='input-wrapper'>";
            $body .= LJ::html_text( { name => 'descriptions_0', class => 'text', id => 'descriptions_0', 'maxlength' => LJ::CMAX_UPIC_DESCRIPTION, value => $descriptions } ) . "\n";
            $body .= LJ::help_icon_html('upic_descriptions') . "\n";
            $body .= "</span>";
            $body .= "</p>\n";
            $body .= "<p class='detail'>$ML{'.label.description.desc'}</p>\n";

            $body .= "<p class='pkg'>\n";
            $body .= "<span id='main_make_default'>";
            $body .= LJ::html_check({ 'type' => 'checkbox',
                                      'name' => 'make_default',
                                      'id' => 'make_default_0',
                                      'value' => '0',
                                      'selected' => @userpics ? 0 : 1,
                                      'accesskey' => $ML{'.makedefault.key'} });
            $body .= "</span>";

            $body .= "<label for='make_default_0'>$ML{'.makedefault'}</label>\n";
            $body .= "</p>\n";
            
            # adding multi-upload option if mogile is enabled
            
            my $remaining_uploads = $max - scalar @userpics;
            if ($remaining_uploads >= 2 && LJ::mogclient()) {
                $body .= "<div id='multi_insert'></div>";
                $body .= "<div id='no_default_insert'></div>";
                $body .= "<p class='pkg' id='multi_insert_buttons'>\n";

                $body .= "<input type='button' value='$ML{'.btn.addfile'}' onclick='javascript:addNewUpload(\"file\");' /> <input type='button' value='$ML{'.btn.addurl'}' onclick='javascript:addNewUpload(\"url\");'/>\n";
                $body .= "<script type='text/javascript'>\n";
                $body .= "maxcounter = $remaining_uploads;\n";
                $body .= "allowComments = true;\n";
                $body .= "allowDescriptions = true;\n";

                $body .= "ep_labels.comment = '$ML{'.label.comment'}';\n";
                $body .= "ep_labels.description = '$ML{'.label.description'}';\n";
                $body .= "ep_labels.fromfile = '$ML{'.fromfile'}';\n";
                $body .= "ep_labels.fromurl = '$ML{'.fromurl'}';\n";
                $body .= "ep_labels.keepdefault = '$ML{'.label.keepdefault'}';\n";
                $body .= "ep_labels.keywords = '$ML{'.label.keywords'}';\n";
                $body .= "ep_labels.makedefault = '$ML{'.makedefault'}';\n";
                $body .= "ep_labels.makedefaultkey = '$ML{'.makedefault.key'}';\n";
                $body .= "ep_labels.remove = '$ML{'.btn.remove'}';\n";
                
                $body .="</script>\n";
                $body .= "</p>\n";
            }

            $body .= "<p class='pkg' id='submit_wrapper'>";
            $body .= LJ::html_submit(undef, $ML{'.btn.proceed'},
                                     { disabled => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "</p>\n";
            $body .= q {
                    </form>
                    </div></div><!-- end #uploadBox -->
                    <div id="uploadStatus" style="display: none;"></div>
                    <div id="progressBar" style="display: none;"></div>
                };

        } else {
            $body .= "<div id='limit'>\n";
            my $inline;
            if ($inline .= LJ::Hooks::run_hook("cprod_inline", $u, 'EditPicsMax')) {
                $body .= $inline;
            } else {
                $body .= BML::ml('.error.toomanypics_standout', { num => $max });
            }
            $body .= "</div><!-- end #limit -->";
        }
        $body .= " \n\n";
    };

    $emit_upload_box->();

    # print out each pic and editing fields
    if ( scalar @userpics ) {
        $body .= "<div id='current_userpics'>";
        $body .= "<form method='post' action='editicons$suffix$getextra'>";
        $body .= LJ::form_auth();

        $body .= qq {
                <?h1 $ML{'.curpics'} h1?>
                <?p $ML{'.curpics.desc2'} p?>
                <div class='EditIconsStatus'>
            };

        $body .= "<p><strong>" . BML::ml( '.piclimitstatus', { current => scalar @userpics, max => $max } ) . "</strong> ";
        $body .= BML::ml( '.view.allicons', { aopts => "href='" . $u->allpics_base . "'" } ) . "</p>";
        if (scalar @userpics >= $max) {
            my $inline;
            if ($inline .= LJ::Hooks::run_hook("cprod_inline", $u, 'EditPics')) {
                $body .= "<?warningbar" . $inline . "warningbar?>";
            } else {
                $body .= "<p>".BML::ml('cprod.editpics.text7.v1',{ "num" => $max })."</p>";
            }
        }

        # show sort options
        $body .= "<p>";
        $body .= $keyword_sort ? '<a href = "/editicons">' . "$ML{'.sort.default'}</a>" : "$ML{'.sort.default'}";
        $body .=" | ";
        $body .= $keyword_sort ? "$ML{'.sort.keyword'}" : '<a href = "/editicons?keywordSort=1">' . "$ML{'.sort.keyword'}</a>";
        $body .= "</p>\n";

        $body .= "</div>";

        $body .= "<div id='list_userpics' style='width: 98%; float: left;'>";

        if ( $keyword_sort ) {
            @userpics = LJ::Userpic->sort( \@userpics );
        }
        
        foreach my $pic ( @userpics ) {
            my $pid = $pic->id;
            
            $body .= "<div class='pkg userpic_wrapper'>";
            $body .= "<span class='EditIconsUserpic'>" .  $pic->imgtag . "</span>\n";

            # FIXME: if no keywords then light grey text and empty out when you click in it
            my $keywords = $pic->keywords;
            my $comment = $pic->comment;
            my $description = $pic->description;
            $body .= "<div class='userpic_controls'  style='float: left; width: auto;'>";
            $body .= "<div class='userpic_keywords pkg'>\n";
            $body .= "<label class='left' for='kw_$pid'>$ML{'.label.keywords'}</label>\n ";
            $body .= LJ::html_text({'name' => "kw_$pid", 'class' => "text", 'id' => "kw_$pid",
                                    'value' => $keywords,
                                    'disabled' => $pic->inactive,
                                    'onfocus' => $display_rename ? "\$(\'rename_div_$pid\').style.display = \'block\';" : ""
                                   }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "kw_orig_$pid",
                                       'value' => $keywords }) . "\n";
            if ($display_rename) {
                $body .= "<div id='rename_div_$pid' class='userpic_rename pkg'>\n";
                $body .= "<script type='text/javascript'>document.getElementById('rename_div_$pid').style.display = 'none';</script>\n";
                if ( $u->userpic_have_mapid ) {
                    $body .= LJ::html_check({ 'type' => 'checkbox', 'name' => "rename_keyword_$pid", 'class' => "checkbox",
                                              'id' => "rename_keyword_$pid", 'value' => 1,
                                              'disabled' => $LJ::DISABLE_MEDIA_UPLOADS });
                    $body .= "<label for='rename_keyword_$pid'>$ML{'.label.rename'}</label>";
                } else {
                    $body .= "$ML{'.label.rename.disabled'}";
                }

                $body .= "</div>\n";
            }
            $body .= "</div>\n";

            $body .= "<div class='userpic_comments pkg'>\n";
            $body .= "<label class='left' for='com_$pid'>$ML{'.label.comment'}</label>\n ";
            $body .= LJ::html_text({ 'name' => "com_$pid", 'class' => "text", 'id' => "com_$pid",
                                     'value' => $comment,
                                     'maxlength' => LJ::CMAX_UPIC_COMMENT,
                                     'disabled' => $pic->inactive }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "com_orig_$pid",
                                       'value' => $comment }) . "\n";

            $body .= "</div>\n";
            
            $body .= "<div class='userpic_descriptions pkg'>\n";
            $body .= "<label class='left' for='desc_$pid'>$ML{'.label.description'}</label>\n ";
            $body .= LJ::html_text({ 'name' => "desc_$pid", 'class' => "text", 'id' => "desc_$pid",
                                     'value' => $description,
                                     'maxlength' => LJ::CMAX_UPIC_DESCRIPTION,
                                     'disabled' => $pic->inactive }) . "\n";
            $body .= LJ::html_hidden({ 'name' => "desc_orig_$pid",
                                       'value' => $description }) . "\n";

            $body .= "</div>\n";
        
            $body .= "<div class='userpic_defaultdelete pkg'>";
            $body .= LJ::html_check({ 'type' => 'radio', 'name' => 'defaultpic', 'class' => "radio", 'value' => $pid,
                                      'selected' => $pic->is_default ? 1 : 0,
                                      'id' => "def_$pid",
                                      'disabled' => $pic->inactive });
            $body .= "<label class='userpic_default_label' for='def_$pid'>$ML{'.label.default'}</label> ";
            $body .= LJ::html_check({ 'type' => 'checkbox', 'name' => "delete_$pid", 'class' => "checkbox",
                                      'id' => "del_$pid", 'value' => 1,
                                      'disabled' => $LJ::DISABLE_MEDIA_UPLOADS });
            $body .= "<label for='del_$pid'>$ML{'.label.delete'}</label>"; 
            if ($pic->inactive) {
                $body .= " &nbsp;<i>[$ML{'userpic.inactive'}]</i> " . LJ::help_icon('userpic_inactive');
            }
            $body .= "</div>";
            $body .= "</div>";
            $body .= "</div>";
            $body .= "<hr class='hr' />";
        }

        $body .= "</div><!-- end #list_userpics -->";
        # no default userpic
        $body .= "<p id='no_default_userpic' style='clear: both;'>";
        $body .= LJ::html_check({ 'name' => 'defaultpic',
                                  'value' => 0,
                                  'type' => 'radio',
                                  'class' => 'radio',
                                  'selected' => $u->{'defaultpicid'} == 0,
                                  'raw' => "id='nodefpic'" });
        $body .= "<label for='nodefpic'>$ML{'.nodefault'}</label></p>";
        $body .= "<div class='action-box'><ul class='inner nostyle'><li>" . LJ::html_submit('action:save', $ML{'.btn.save'}) . "</li></ul></div><div class='clear-floats'></div>";
        $body .= "</form>";
        $body .= "</div><!-- end #current_userpics -->";
        $body .= "<script type='text/javascript'>\n";
        $body .= "editiconsInit();\n";
        $body .= "</script>\n";

    } else {
        $body .= qq {
                <?h1 $ML{'.nopics'} h1?>
                <?p $ML{'.noneupload2'} p?>
            };
    }

    
    return;
}

sub update_userpics
{
    my $userpicsref = shift;
    my $u = shift;
    my @userpics = @$userpicsref;
    my $err = shift;

    my $display_rename = LJ::is_enabled( "icon_renames" ) ? 1 : 0 ;

    # form being posted isn't multipart, since we were able to read from %POST
    unless (LJ::check_form_auth()) {
        return $err->($ML{'error.invalidform'});
    }

    my @delete; # userpic objects to delete
    my @inactive_picids;
    my %picid_of_kwid;
    my %used_keywords;

    # we need to count keywords based on what the user provided, in order
    # to find duplicates. $up->keywords doesn't work, because re-using a
    # keyword will remove it from the other userpic without our knowing
    my $count_keywords = sub {
        my $kwlist = shift;
        $used_keywords{$_}++ foreach split(/,\s*/, $kwlist);
    };

    foreach my $up (@userpics) {

        my $picid = $up->id;
        
        # delete this pic
        if ($POST{"delete_$picid"}) {
            push @delete, $up;
            next;
        }
        
        # we're only going to modify keywords/comments on active pictures
        if ($up->inactive) {
            # use 'orig' because we don't POST disabled fields
            $count_keywords->($POST{"kw_orig_$picid"});
            next;
        }
        
        $count_keywords->($POST{"kw_$picid"});
        
        # only modify if changing the data, make sure not collidiing with other edits, etc
        if ($POST{"kw_$picid"} ne $POST{"kw_orig_$picid"}) {
            my $kws = $POST{"kw_$picid"};

            if ( $POST{"rename_keyword_$picid"} ) {
                if ( $display_rename && $u->userpic_have_mapid ) {
                    eval {
                       $up->set_and_rename_keywords($kws, $POST{"kw_orig_$picid"});
                    } or push @errors, $@->as_html;
                } else {
                    push @errors, $ML{'.label.rename.disabled'};
                }
            } else {
                eval {
                    $up->set_keywords($kws);
                } or push @errors, $@;
            }
        }
        
        eval {
            $up->set_comment ($POST{"com_$picid"})
                unless $POST{"com_$picid"} eq $POST{"com_orig_$picid"};
        } or push @errors, $@;
        
        eval {
            $up->set_description ($POST{"desc_$picid"})
                unless $POST{"desc_$picid"} eq $POST{"desc_orig_$picid"};
        } or push @errors, $@;

    }
    
    foreach my $kw (keys %used_keywords) {
        next unless $used_keywords{$kw} > 1;
        push @errors, BML::ml('.error.keywords', {ekw => $kw});
    }
    
    if (@delete && $LJ::DISABLE_MEDIA_UPLOADS) {
        push @errors, $ML{'.error.nomediauploads.delete'};
        
    } elsif (@delete) {
        
        # delete pics
        foreach my $up (@delete) {
            eval { $up->delete; } or push @errors, $@;
        }
        
        # if any of the userpics they want to delete are active, then we want to
        # re-run activate_userpics() - turns out it's faster to not check to
        # see if we need to do this
        $u->activate_userpics;
    }
    
    my $new_default = $POST{'defaultpic'}+0;
    if ($POST{"delete_${new_default}"}) {
        # deleting default
        $new_default = 0;
    }
    
    if ($new_default && $new_default != $u->{'defaultpicid'}) {
        my ($up) = grep { $_->id == $new_default } @userpics;
        
        # see if they are trying to make an inactive userpic their default
        if ($up && !$up->inactive) {
            $up->make_default;
        }
    } elsif ($new_default eq '0' && $u->{'defaultpicid'}) {
        # selected the "no default picture" option
        $u->update_self( { defaultpicid => 0 } );
        $u->{'defaultpicid'} = 0;
    }
    
    return scalar @delete;
}

sub parse_post_uploads
{
    my $postref = shift;
    my %POST = %$postref;
    my $u = shift;
    my $MAX_UPLOAD = shift;
    my $factory_disabled = shift;


    my @uploads;
    
    # if we find a userpic that requires the factory, save it here.
    # we can only have one.
    my $requires_factory;
    
    # go through each key and create a %current_upload for it, then
    # put it in @uploads.
    foreach my $userpic_key (keys %POST) {
        # uploaded pics
        if ($userpic_key =~ /userpic_.*/) {
            # only use userpic_0 if we selected file for the source    
            unless ($userpic_key eq "userpic_0" && $POST{"src"} ne "file") {
                # copy all of the basic settings into the hash.
                my %current_upload;
                $current_upload{key} = $userpic_key;
                my @tokens = split(/_/, $userpic_key);
                my $counter = $tokens[1];
                $current_upload{keywords} = $POST{"keywords_$counter"};
                $current_upload{comments} = $POST{"comments_$counter"};
                $current_upload{descriptions} = $POST{"descriptions_$counter"};
                $current_upload{index} = $counter;
                $current_upload{image} = \$POST{$userpic_key};
                $current_upload{make_default} =  ($POST{"make_default"} eq $counter);

                # check the image size.
                my $imgdata = $POST{"spool_fh_$counter"} ? $POST{"spool_fh_$counter"} : \$POST{$userpic_key};
                my $size = length($$imgdata);
                
                if ($size == 0) {
                    $current_upload{error} = $ML{'.error.nofile'};
                } else {
                    my ($imagew, $imageh, $filetype) = Image::Size::imgsize($imgdata);
                    my $size = length($imgdata);
                    
                    if (!$imagew || !$imageh) {
                        # couldn't parse the file
                        $current_upload{error} = BML::ml(".error.unsupportedtype", {filetype => $filetype});
                    } elsif ($imagew > 5000 || $imageh > 5000) {
                        # file is too big, no matter what.
                        $current_upload{error} = "The dimensions of this image are too large.";
                    } elsif (int($imagew) > 100 || int($imageh) > 100 || $size > $MAX_UPLOAD) {
                        # file is too large.  
                        if ($factory_disabled) {
                            if (int($imagew) > 100 || int($imageh) > 100) {
                                $current_upload{error} = BML::ml('.error.imagetoolarge', {imagesize => "${imagew}x$imageh"});
                            } else {
                                $current_upload{error} = BML::ml('.error.filetoolarge', { 'maxsize' => int($MAX_UPLOAD / 1024) });
                            }
                        } elsif ($filetype ne 'JPG' && $filetype ne 'PNG') {
                            # factory only works on jpegs and pngs because Image::Magick has issues
                            if (int($imagew) > 100 || int($imageh) > 100) {
                                $current_upload{error} = $ML{'.error.giffiledimensions'};
                            } else {
                                $current_upload{error} = BML::ml('.error.filetoolarge', { 'maxsize' => int($MAX_UPLOAD / 1024)});
                            }
                        } elsif ($imagew <= 100 && $imageh <= 100) {
                            # if it's the right size, just too large a file, see if we can
                            # resize it down
                            unless ($POST{"spool_file_name_$counter"}) {
                                LJ::mogclient()->store_content("upf_${counter}:$u->{userid}", "temp", \$POST{$userpic_key});
                            }
                            
                            eval {
                                my $picinfo = LJ::Userpic->get_upf_scaled(
                                    size => 100,
                                    u    => $u,
                                    mogkey => "upf_${counter}:$u->{userid}"
                                    );
                                
                                # success! don't go to the factory, and pretend the user just uploaded the file
                                # and continue on normally
                                $current_upload{image} = \${ $picinfo->[0] };
                            };
                            
                            if ($@ || (length($POST{$userpic_key}) > $MAX_UPLOAD)) {
                                $current_upload{error} = ML::ml('.error.filetoolarge', {maxsize => int($MAX_UPLOAD / 1024) });
                            }
                        } else {
                            # this is a candidate for the userpicfactory.
                            
                            # we can only do a single pic in the factory, so if there are two,
                            # then error out for both.
                            if ($requires_factory) {
                                $requires_factory -> {error} = $ML{'.error.multipleresize'};
                                $current_upload{error} = $ML{'.error.multipleresize'};
                                $requires_factory->{requires_factory} = 0;
                            } else {
                                $current_upload{requires_factory} = 1;
                                $current_upload{imageh} = $imageh;
                                $current_upload{imagew} = $imagew;
                                if ($POST{"spool_fh_$counter"}) {
                                    $current_upload{spool_fh} = $POST{"spool_fh_$counter"};
                                }
                                $requires_factory = \%current_upload;
                            }
                        }
                    } else {
                        # valid file; just add it as given.
                        if ($POST{"spool_file_name_$counter"}) {
                            $current_upload{image} = LJ::mogclient()->get_file_data($POST{"spool_file_name_$counter"});
                        }
                    }
                }
                push @uploads, \%current_upload;
            }
        } elsif ($userpic_key =~ /urlpic_.*/) {
            # go through the URL uploads
            unless ($userpic_key eq "urlpic_0" && $POST{src} ne "url") {
                # copy all of the basic settings into the hash.
                my %current_upload;
                $current_upload{key} = $userpic_key;
                my @tokens = split(/_/, $userpic_key);
                my $counter = $tokens[1];
                $current_upload{keywords} = $POST{"keywords_$counter"};
                $current_upload{comments} = $POST{"comments_$counter"};
                $current_upload{descriptions} = $POST{"descriptions_$counter"};
                $current_upload{index} = $counter;
                $current_upload{make_default} =  ($POST{"make_default"} eq $counter);

                if (! $POST{$userpic_key}) {
                    $current_upload{error} = $ML{'.error.nourl'};
                } elsif ($POST{$userpic_key} !~ /^http:\/\//) {
                    $current_upload{error} = $ML{'.error.badurl'};
                } else {
                    my $ua = LJ::get_useragent(
                        role     => 'userpic',
                        max_size => $MAX_UPLOAD + 1024,
                        timeout  => 10,
                        );
                    my $res = $ua->get($POST{$userpic_key});
                    $current_upload{image} = \$res->content if $res && $res->is_success;
                    $current_upload{error} = $ML{'.error.urlerror'} unless $current_upload{image};
                    # Below, $current_upload{image} needs to be dereferenced because it contains a hash value.
                    $current_upload{error} = $ML{'.error.urlfiletoolarge'} if $current_upload{image} && length( ${ $current_upload{image} } ) > $MAX_UPLOAD;
                }
                push @uploads, \%current_upload;
            }
        }
    }

    return @uploads;
}

sub parse_large_upload 
{
    my $postref = shift;
    my $errorref = shift;
    my $user = shift;
    my $err = shift;

    my %upload = (); # { spool_fh, spool_path, filename, bytes, md5sum, md5ctx, mime }
    my @uploaded_files = ();
    my $curr_name;

    # called when the beginning of an upload is encountered
    my $hook_newheaders = sub {
        my ($name, $filename) = @_;

        # for uploaded files, just set POST value to filename
        $postref->{$name} = '';
        
        $curr_name = $name;
        
        return 1 unless $curr_name =~ /userpic.*/;
        
        # new file, need to create a filehandle, etc
        %upload = ();
        $upload{filename} = $filename;
        $upload{md5ctx} = new Digest::MD5;
        
        # get MogileFS filehandle
        return $err->("Sorry, MogileFS must be running to handle the uploading of large images.") unless LJ::mogclient();
        
        my @tokens = split(/_/, $curr_name);
        my $counter = $tokens[1];

        $upload{spool_file_name} = "upf_${counter}:$user->{userid}";
        $upload{spool_fh} = LJ::mogclient()->new_file($upload{spool_file_name}, 'temp')
            or die "Failed to open MogileFS tempfile";
        
        push @uploaded_files, $upload{spool_file_name};
        return 1;
    };
    
    # called as data is received
    my $hook_data = sub {
        my ($len, $data) = @_;
        
        unless ($curr_name =~ /userpic.*/) {
            $postref->{$curr_name} .= $data;
            return 1;
        }

        # check that we've not exceeded the max read limit
        my $max_read = (1<<20) * 5; # 5 MiB
        my $len_read = 0;
        
        $len_read = ($upload{bytes} += $len);
        
        die "Upload max exceeded at $len_read bytes"
            if $len_read > $max_read;
        
        $upload{md5ctx}->add($data);
        $upload{spool_fh}->print($data);

        return 1;
    };
    
    # called when the end of an upload is encountered
    my $hook_enddata = sub {
        return 1 unless $curr_name =~ /userpic.*/;

        # since we've just finished a potentially slow upload, we need to
        # make sure the database handles in DBI::Role's cache haven't expired,
        # so we'll just trigger a revalidation now so that subsequent database
        # calls will be safe.
        $LJ::DBIRole->clear_req_cache();
        
        # don't try to operate on 0-length spoolfiles
        unless ($upload{bytes}) {
            %upload = ();
            return 1;
        }

        # read magic and try to determine formatid of uploaded file. This
        # doesn't use fh->tell and fh->seek because the filehandle is
        # sysopen()ed, so isn't really an IO::Seekable like an IO::File
        # filehandle would be.
        my $magic;
        tell $upload{spool_fh}
        or die "read offset is 0, empty file?";
        seek $upload{spool_fh}, 0, 0;

        # $! should always be set in this case because a failed read will
        # always be an error, not EOF, which is handled above (tell)
        $upload{spool_fh}->read($magic, 20)
            or die "Couldn't read magic: $!";
        
        $upload{spool_fh}->close
            or die "Can't close Mogile filehandle";
        
        my $format_magic = sub {
            my $magic = shift;
            my $hex = unpack "H*", $magic;
            my $mime;
            
            # image formats
            $mime = 'image/jpeg' if $magic =~ /^\xff\xd8/; # JPEG
            $mime = 'image/gif'  if $magic =~ /^GIF8/;     # GIF
            $mime = 'image/png'  if $magic =~ /^\x89PNG/;  # PNG
            
            return $mime;
        };
        
        $upload{mime} = $format_magic->( $magic );
        unless ( $upload{mime} ) {
            $$errorref = "Unknown format for upload";
            return $err->( $$errorref );
        }
        
        # finished adding data for md5, create digest (but don't destroy original)
        $upload{md5sum} = $upload{md5ctx}->digest;
        
        my @tokens = split(/_/, $curr_name);
        my $counter = $tokens[1];

        $postref->{$curr_name} = $upload{spool_fh};
        $postref->{"spool_file_name_$counter"} = $upload{spool_file_name};
        $postref->{"spool_fh_$counter"} = $upload{spool_fh};

        return 1;
    };
    
    
    # parse multipart-mime submission, one chunk at a time,
    # calling our hooks as we go to put uploads in temporary
    # MogileFS filehandles
    my $retval = eval { BML::parse_multipart_interactive($errorref, {
        newheaders => $hook_newheaders,
        data       => $hook_data,
        enddata    => $hook_enddata,
                                                         }); };
    
    # if BML::Parse_multipart_interactive failed, we need to add
    # all of our gpics to the gpic_delete queue.  if any of them
    # still have refcounts, they won't really be deleted because
    # the async job will realize and leave them alone
    unless ($retval) {
        # if we hit a parse error, delete the uploaded files
        foreach my $mogkey (@uploaded_files) {
            LJ::mogclient()->delete($mogkey);
        }

        if (index(lc($$errorref), 'unknown format') == 0) {
            return $err->(BML::ml(".error.unknowntype"));
        }
        return $err->("couldn't parse upload: $$errorref");
    }

    return $retval;
}

_code?><?page
    head=><?_code return $head; _code?>
    title=><?_code return $title; _code?>
    body=><?_code return $body; _code?>
    page?>
